
leitorrf.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004b0  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000430  20000000  000004b0  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000020  20000430  000008e0  00010430  2**2
                  ALLOC
  3 .stack        00000200  20000450  00000900  00010430  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00010430  2**0
                  CONTENTS, READONLY
  5 .comment      00000071  00000000  00000000  00010458  2**0
                  CONTENTS, READONLY
  6 .debug_info   00005767  00000000  00000000  000104c9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b4d  00000000  00000000  00015c30  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00000500  00000000  00000000  0001677d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000118  00000000  00000000  00016c7d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000000a0  00000000  00000000  00016d95  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00008938  00000000  00000000  00016e35  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00001dd2  00000000  00000000  0001f76d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00032507  00000000  00000000  0002153f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000198  00000000  00000000  00053a48  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
   0:	20000650 	.word	0x20000650
   4:	00000161 	.word	0x00000161
   8:	0000015d 	.word	0x0000015d
   c:	0000015d 	.word	0x0000015d
	...
  2c:	0000015d 	.word	0x0000015d
	...
  38:	0000015d 	.word	0x0000015d
  3c:	0000015d 	.word	0x0000015d
  40:	0000015d 	.word	0x0000015d
  44:	0000015d 	.word	0x0000015d
  48:	0000015d 	.word	0x0000015d
  4c:	0000015d 	.word	0x0000015d
  50:	0000015d 	.word	0x0000015d
  54:	0000015d 	.word	0x0000015d
  58:	0000015d 	.word	0x0000015d
  5c:	0000015d 	.word	0x0000015d
  60:	0000015d 	.word	0x0000015d
  64:	0000015d 	.word	0x0000015d
  68:	0000015d 	.word	0x0000015d
  6c:	0000015d 	.word	0x0000015d
  70:	0000015d 	.word	0x0000015d
  74:	0000015d 	.word	0x0000015d
  78:	0000015d 	.word	0x0000015d
  7c:	0000015d 	.word	0x0000015d
  80:	0000015d 	.word	0x0000015d
  84:	0000015d 	.word	0x0000015d
  88:	0000015d 	.word	0x0000015d
  8c:	0000015d 	.word	0x0000015d
  90:	0000015d 	.word	0x0000015d
  94:	0000015d 	.word	0x0000015d
  98:	0000015d 	.word	0x0000015d
  9c:	0000015d 	.word	0x0000015d

000000a0 <deregister_tm_clones>:
  a0:	b508      	push	{r3, lr}
  a2:	4b06      	ldr	r3, [pc, #24]	; (bc <deregister_tm_clones+0x1c>)
  a4:	4806      	ldr	r0, [pc, #24]	; (c0 <deregister_tm_clones+0x20>)
  a6:	3303      	adds	r3, #3
  a8:	1a19      	subs	r1, r3, r0
  aa:	2906      	cmp	r1, #6
  ac:	d800      	bhi.n	b0 <deregister_tm_clones+0x10>
  ae:	bd08      	pop	{r3, pc}
  b0:	4a04      	ldr	r2, [pc, #16]	; (c4 <deregister_tm_clones+0x24>)
  b2:	2a00      	cmp	r2, #0
  b4:	d0fb      	beq.n	ae <deregister_tm_clones+0xe>
  b6:	4790      	blx	r2
  b8:	e7f9      	b.n	ae <deregister_tm_clones+0xe>
  ba:	46c0      	nop			; (mov r8, r8)
  bc:	000004b0 	.word	0x000004b0
  c0:	000004b0 	.word	0x000004b0
  c4:	00000000 	.word	0x00000000

000000c8 <register_tm_clones>:
  c8:	b508      	push	{r3, lr}
  ca:	4807      	ldr	r0, [pc, #28]	; (e8 <register_tm_clones+0x20>)
  cc:	4b07      	ldr	r3, [pc, #28]	; (ec <register_tm_clones+0x24>)
  ce:	1a19      	subs	r1, r3, r0
  d0:	108b      	asrs	r3, r1, #2
  d2:	0fda      	lsrs	r2, r3, #31
  d4:	18d1      	adds	r1, r2, r3
  d6:	1049      	asrs	r1, r1, #1
  d8:	d100      	bne.n	dc <register_tm_clones+0x14>
  da:	bd08      	pop	{r3, pc}
  dc:	4b04      	ldr	r3, [pc, #16]	; (f0 <register_tm_clones+0x28>)
  de:	2b00      	cmp	r3, #0
  e0:	d0fb      	beq.n	da <register_tm_clones+0x12>
  e2:	4798      	blx	r3
  e4:	e7f9      	b.n	da <register_tm_clones+0x12>
  e6:	46c0      	nop			; (mov r8, r8)
  e8:	000004b0 	.word	0x000004b0
  ec:	000004b0 	.word	0x000004b0
  f0:	00000000 	.word	0x00000000

000000f4 <__do_global_dtors_aux>:
  f4:	b510      	push	{r4, lr}
  f6:	4c07      	ldr	r4, [pc, #28]	; (114 <__do_global_dtors_aux+0x20>)
  f8:	7823      	ldrb	r3, [r4, #0]
  fa:	2b00      	cmp	r3, #0
  fc:	d109      	bne.n	112 <__do_global_dtors_aux+0x1e>
  fe:	f7ff ffcf 	bl	a0 <deregister_tm_clones>
 102:	4805      	ldr	r0, [pc, #20]	; (118 <__do_global_dtors_aux+0x24>)
 104:	2800      	cmp	r0, #0
 106:	d002      	beq.n	10e <__do_global_dtors_aux+0x1a>
 108:	4804      	ldr	r0, [pc, #16]	; (11c <__do_global_dtors_aux+0x28>)
 10a:	e000      	b.n	10e <__do_global_dtors_aux+0x1a>
 10c:	bf00      	nop
 10e:	2101      	movs	r1, #1
 110:	7021      	strb	r1, [r4, #0]
 112:	bd10      	pop	{r4, pc}
 114:	20000430 	.word	0x20000430
 118:	00000000 	.word	0x00000000
 11c:	000004b0 	.word	0x000004b0

00000120 <frame_dummy>:
 120:	b508      	push	{r3, lr}
 122:	4b09      	ldr	r3, [pc, #36]	; (148 <frame_dummy+0x28>)
 124:	2b00      	cmp	r3, #0
 126:	d003      	beq.n	130 <frame_dummy+0x10>
 128:	4808      	ldr	r0, [pc, #32]	; (14c <frame_dummy+0x2c>)
 12a:	4909      	ldr	r1, [pc, #36]	; (150 <frame_dummy+0x30>)
 12c:	e000      	b.n	130 <frame_dummy+0x10>
 12e:	bf00      	nop
 130:	4808      	ldr	r0, [pc, #32]	; (154 <frame_dummy+0x34>)
 132:	6801      	ldr	r1, [r0, #0]
 134:	2900      	cmp	r1, #0
 136:	d003      	beq.n	140 <frame_dummy+0x20>
 138:	4a07      	ldr	r2, [pc, #28]	; (158 <frame_dummy+0x38>)
 13a:	2a00      	cmp	r2, #0
 13c:	d000      	beq.n	140 <frame_dummy+0x20>
 13e:	4790      	blx	r2
 140:	f7ff ffc2 	bl	c8 <register_tm_clones>
 144:	bd08      	pop	{r3, pc}
 146:	46c0      	nop			; (mov r8, r8)
 148:	00000000 	.word	0x00000000
 14c:	000004b0 	.word	0x000004b0
 150:	20000434 	.word	0x20000434
 154:	000004b0 	.word	0x000004b0
 158:	00000000 	.word	0x00000000

0000015c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
 15c:	b500      	push	{lr}
 15e:	e7fe      	b.n	15e <Dummy_Handler+0x2>

00000160 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
 160:	b508      	push	{r3, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
 162:	4b19      	ldr	r3, [pc, #100]	; (1c8 <Reset_Handler+0x68>)
 164:	4a19      	ldr	r2, [pc, #100]	; (1cc <Reset_Handler+0x6c>)
 166:	429a      	cmp	r2, r3
 168:	d003      	beq.n	172 <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
 16a:	4b19      	ldr	r3, [pc, #100]	; (1d0 <Reset_Handler+0x70>)
 16c:	4a16      	ldr	r2, [pc, #88]	; (1c8 <Reset_Handler+0x68>)
 16e:	429a      	cmp	r2, r3
 170:	d304      	bcc.n	17c <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
 172:	4b18      	ldr	r3, [pc, #96]	; (1d4 <Reset_Handler+0x74>)
 174:	4a18      	ldr	r2, [pc, #96]	; (1d8 <Reset_Handler+0x78>)
 176:	429a      	cmp	r2, r3
 178:	d30f      	bcc.n	19a <Reset_Handler+0x3a>
 17a:	e01b      	b.n	1b4 <Reset_Handler+0x54>
 17c:	4a13      	ldr	r2, [pc, #76]	; (1cc <Reset_Handler+0x6c>)

/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
 17e:	4b17      	ldr	r3, [pc, #92]	; (1dc <Reset_Handler+0x7c>)
 180:	4913      	ldr	r1, [pc, #76]	; (1d0 <Reset_Handler+0x70>)
 182:	3103      	adds	r1, #3
 184:	1ac9      	subs	r1, r1, r3
 186:	0889      	lsrs	r1, r1, #2
 188:	3101      	adds	r1, #1
 18a:	0089      	lsls	r1, r1, #2
 18c:	3b04      	subs	r3, #4
 18e:	18c9      	adds	r1, r1, r3
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
                        *pDest++ = *pSrc++;
 190:	ca01      	ldmia	r2!, {r0}
 192:	c301      	stmia	r3!, {r0}
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
 194:	428b      	cmp	r3, r1
 196:	d1fb      	bne.n	190 <Reset_Handler+0x30>
 198:	e7eb      	b.n	172 <Reset_Handler+0x12>

/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
 19a:	4b11      	ldr	r3, [pc, #68]	; (1e0 <Reset_Handler+0x80>)
 19c:	490d      	ldr	r1, [pc, #52]	; (1d4 <Reset_Handler+0x74>)
 19e:	3103      	adds	r1, #3
 1a0:	1ac9      	subs	r1, r1, r3
 1a2:	0889      	lsrs	r1, r1, #2
 1a4:	3101      	adds	r1, #1
 1a6:	0089      	lsls	r1, r1, #2
 1a8:	3b04      	subs	r3, #4
 1aa:	18c9      	adds	r1, r1, r3
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
                *pDest++ = 0;
 1ac:	2200      	movs	r2, #0
 1ae:	c304      	stmia	r3!, {r2}
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
 1b0:	428b      	cmp	r3, r1
 1b2:	d1fc      	bne.n	1ae <Reset_Handler+0x4e>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
 1b4:	4b0b      	ldr	r3, [pc, #44]	; (1e4 <Reset_Handler+0x84>)
 1b6:	21ff      	movs	r1, #255	; 0xff
 1b8:	4a0b      	ldr	r2, [pc, #44]	; (1e8 <Reset_Handler+0x88>)
 1ba:	438a      	bics	r2, r1
 1bc:	609a      	str	r2, [r3, #8]

        /* Initialize the C library */
		// ALBERT: Esta é a linha que devemos desabilitar se quisermos mais RAM
		//			em compensação, perdemos o direito de usar a libc
        __libc_init_array();
 1be:	4b0b      	ldr	r3, [pc, #44]	; (1ec <Reset_Handler+0x8c>)
 1c0:	4798      	blx	r3

        /* Branch to main function */
        main();
 1c2:	4b0b      	ldr	r3, [pc, #44]	; (1f0 <Reset_Handler+0x90>)
 1c4:	4798      	blx	r3
 1c6:	e7fe      	b.n	1c6 <Reset_Handler+0x66>
 1c8:	20000000 	.word	0x20000000
 1cc:	000004b0 	.word	0x000004b0
 1d0:	20000430 	.word	0x20000430
 1d4:	20000450 	.word	0x20000450
 1d8:	20000430 	.word	0x20000430
 1dc:	20000004 	.word	0x20000004
 1e0:	20000434 	.word	0x20000434
 1e4:	e000ed00 	.word	0xe000ed00
 1e8:	00000000 	.word	0x00000000
 1ec:	00000411 	.word	0x00000411
 1f0:	00000319 	.word	0x00000319

000001f4 <ClockInit>:

	return 0;
}

void ClockInit()
{
 1f4:	b530      	push	{r4, r5, lr}
	int i;
	/* Workaround for errata 10558 */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD12RDY | SYSCTRL_INTFLAG_BOD33RDY |
 1f6:	4b27      	ldr	r3, [pc, #156]	; (294 <STACK_SIZE+0x94>)
 1f8:	4a27      	ldr	r2, [pc, #156]	; (298 <STACK_SIZE+0x98>)
 1fa:	609a      	str	r2, [r3, #8]

#include "sam.h"

static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	NVMCTRL->CTRLB.bit.RWS = wait_states;
 1fc:	4a27      	ldr	r2, [pc, #156]	; (29c <STACK_SIZE+0x9c>)
 1fe:	6851      	ldr	r1, [r2, #4]
 200:	201e      	movs	r0, #30
 202:	4381      	bics	r1, r0
 204:	6051      	str	r1, [r2, #4]
	
	/* Configura os wait states de acesso à memória */
	system_flash_set_waitstates(0);
	
	//Inicializar OSC8M
	SYSCTRL->OSC8M.bit.PRESC = 0;
 206:	6a19      	ldr	r1, [r3, #32]
 208:	4a25      	ldr	r2, [pc, #148]	; (2a0 <STACK_SIZE+0xa0>)
 20a:	400a      	ands	r2, r1
 20c:	621a      	str	r2, [r3, #32]
	SYSCTRL->OSC8M.bit.ONDEMAND = 1;
 20e:	6a19      	ldr	r1, [r3, #32]
 210:	2280      	movs	r2, #128	; 0x80
 212:	430a      	orrs	r2, r1
 214:	621a      	str	r2, [r3, #32]
	SYSCTRL->OSC8M.bit.RUNSTDBY = 0;
 216:	6a1a      	ldr	r2, [r3, #32]
 218:	2140      	movs	r1, #64	; 0x40
 21a:	438a      	bics	r2, r1
 21c:	621a      	str	r2, [r3, #32]
	SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
 21e:	6a19      	ldr	r1, [r3, #32]
 220:	2202      	movs	r2, #2
 222:	430a      	orrs	r2, r1
 224:	621a      	str	r2, [r3, #32]
	///TODO: Inicializar Oscilador Externo de 8/16MHz
	///TODO: Inicializar DFLL para 48MHz
	
	
	//Inicializa GCLK
	PM->APBAMASK.reg |= PM_APBAMASK_GCLK;
 226:	4b1f      	ldr	r3, [pc, #124]	; (2a4 <STACK_SIZE+0xa4>)
 228:	6999      	ldr	r1, [r3, #24]
 22a:	2208      	movs	r2, #8
 22c:	430a      	orrs	r2, r1
 22e:	619a      	str	r2, [r3, #24]

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
 230:	2201      	movs	r2, #1
 232:	4b1d      	ldr	r3, [pc, #116]	; (2a8 <STACK_SIZE+0xa8>)
 234:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {/* Wait for reset to complete */};
 236:	1c19      	adds	r1, r3, #0
 238:	780b      	ldrb	r3, [r1, #0]
 23a:	421a      	tst	r2, r3
 23c:	d1fc      	bne.n	238 <STACK_SIZE+0x38>
 23e:	2107      	movs	r1, #7
		
	for (i=7;i>=0;i--)
	{
		/* Select the correct generator */
		*((uint8_t*)&GCLK->GENDIV.reg) = (uint8_t)i;
 240:	4d1a      	ldr	r5, [pc, #104]	; (2ac <STACK_SIZE+0xac>)
	NVMCTRL->CTRLB.bit.RWS = wait_states;
}

static inline int system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) {
 242:	4b19      	ldr	r3, [pc, #100]	; (2a8 <STACK_SIZE+0xa8>)
	{
		/* Select the correct generator */
		*((uint8_t*)&GCLK->GENDIV.reg) = (uint8_t)i;
		/* Write the new generator configuration */
		while (system_gclk_is_syncing()) {/* Wait for synchronization */};
		GCLK->GENDIV.reg  = 1;
 244:	2401      	movs	r4, #1
		while (system_gclk_is_syncing()) {/* Wait for synchronization */};
		GCLK->GENCTRL.reg = (GCLK_SOURCE_OSC8M << GCLK_GENCTRL_SRC_Pos) | GCLK_GENCTRL_GENEN;
 246:	2083      	movs	r0, #131	; 0x83
 248:	0240      	lsls	r0, r0, #9
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {/* Wait for reset to complete */};
		
	for (i=7;i>=0;i--)
	{
		/* Select the correct generator */
		*((uint8_t*)&GCLK->GENDIV.reg) = (uint8_t)i;
 24a:	7029      	strb	r1, [r5, #0]
	NVMCTRL->CTRLB.bit.RWS = wait_states;
}

static inline int system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) {
 24c:	785a      	ldrb	r2, [r3, #1]
	for (i=7;i>=0;i--)
	{
		/* Select the correct generator */
		*((uint8_t*)&GCLK->GENDIV.reg) = (uint8_t)i;
		/* Write the new generator configuration */
		while (system_gclk_is_syncing()) {/* Wait for synchronization */};
 24e:	b252      	sxtb	r2, r2
 250:	2a00      	cmp	r2, #0
 252:	dbfb      	blt.n	24c <STACK_SIZE+0x4c>
		GCLK->GENDIV.reg  = 1;
 254:	609c      	str	r4, [r3, #8]
	NVMCTRL->CTRLB.bit.RWS = wait_states;
}

static inline int system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) {
 256:	785a      	ldrb	r2, [r3, #1]
		/* Select the correct generator */
		*((uint8_t*)&GCLK->GENDIV.reg) = (uint8_t)i;
		/* Write the new generator configuration */
		while (system_gclk_is_syncing()) {/* Wait for synchronization */};
		GCLK->GENDIV.reg  = 1;
		while (system_gclk_is_syncing()) {/* Wait for synchronization */};
 258:	b252      	sxtb	r2, r2
 25a:	2a00      	cmp	r2, #0
 25c:	dbfb      	blt.n	256 <STACK_SIZE+0x56>
		GCLK->GENCTRL.reg = (GCLK_SOURCE_OSC8M << GCLK_GENCTRL_SRC_Pos) | GCLK_GENCTRL_GENEN;
 25e:	6058      	str	r0, [r3, #4]

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {/* Wait for reset to complete */};
		
	for (i=7;i>=0;i--)
 260:	3901      	subs	r1, #1
 262:	d2f2      	bcs.n	24a <STACK_SIZE+0x4a>
 264:	2113      	movs	r1, #19
	NVMCTRL->CTRLB.bit.RWS = wait_states;
}

static inline int system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) {
 266:	4a10      	ldr	r2, [pc, #64]	; (2a8 <STACK_SIZE+0xa8>)
	}
	
	for (i=0x13; i<=0x16;i++)
	{
		while (system_gclk_is_syncing()) {/* Wait for synchronization */};
		*((uint8_t*)&GCLK->CLKCTRL.reg) = (uint8_t)i;
 268:	4c11      	ldr	r4, [pc, #68]	; (2b0 <STACK_SIZE+0xb0>)
		GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
 26a:	2080      	movs	r0, #128	; 0x80
 26c:	01c0      	lsls	r0, r0, #7
	NVMCTRL->CTRLB.bit.RWS = wait_states;
}

static inline int system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) {
 26e:	7853      	ldrb	r3, [r2, #1]
		GCLK->GENCTRL.reg = (GCLK_SOURCE_OSC8M << GCLK_GENCTRL_SRC_Pos) | GCLK_GENCTRL_GENEN;
	}
	
	for (i=0x13; i<=0x16;i++)
	{
		while (system_gclk_is_syncing()) {/* Wait for synchronization */};
 270:	b25b      	sxtb	r3, r3
 272:	2b00      	cmp	r3, #0
 274:	dbfb      	blt.n	26e <STACK_SIZE+0x6e>
		*((uint8_t*)&GCLK->CLKCTRL.reg) = (uint8_t)i;
 276:	7021      	strb	r1, [r4, #0]
		GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
 278:	8853      	ldrh	r3, [r2, #2]
 27a:	4303      	orrs	r3, r0
 27c:	8053      	strh	r3, [r2, #2]
		GCLK->GENDIV.reg  = 1;
		while (system_gclk_is_syncing()) {/* Wait for synchronization */};
		GCLK->GENCTRL.reg = (GCLK_SOURCE_OSC8M << GCLK_GENCTRL_SRC_Pos) | GCLK_GENCTRL_GENEN;
	}
	
	for (i=0x13; i<=0x16;i++)
 27e:	3101      	adds	r1, #1
 280:	2917      	cmp	r1, #23
 282:	d1f4      	bne.n	26e <STACK_SIZE+0x6e>
		*((uint8_t*)&GCLK->CLKCTRL.reg) = (uint8_t)i;
		GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
	}
	
	//Set CPU, APBA and APBB clocks
	PM->CPUSEL.reg = (uint32_t)0;
 284:	4b07      	ldr	r3, [pc, #28]	; (2a4 <STACK_SIZE+0xa4>)
 286:	2200      	movs	r2, #0
 288:	721a      	strb	r2, [r3, #8]
	PM->APBASEL.reg = (uint32_t)0;
 28a:	725a      	strb	r2, [r3, #9]
	PM->APBBSEL.reg = (uint32_t)0;
 28c:	729a      	strb	r2, [r3, #10]
	PM->APBCSEL.reg = (uint32_t)0;
 28e:	72da      	strb	r2, [r3, #11]
}
 290:	bd30      	pop	{r4, r5, pc}
 292:	46c0      	nop			; (mov r8, r8)
 294:	40000800 	.word	0x40000800
 298:	00003610 	.word	0x00003610
 29c:	41004000 	.word	0x41004000
 2a0:	fffffcff 	.word	0xfffffcff
 2a4:	40000400 	.word	0x40000400
 2a8:	40000c00 	.word	0x40000c00
 2ac:	40000c08 	.word	0x40000c08
 2b0:	40000c02 	.word	0x40000c02

000002b4 <Init125khz>:



//Esta função inicializa o TC2 WO[0] --> Pino do 125kHz da antena
void Init125khz(void)
{
 2b4:	b500      	push	{lr}
	//Associa o pino de 125kHz ao TC2
	PORT->Group[0].PINCFG[0].bit.PMUXEN = 1;
 2b6:	4b15      	ldr	r3, [pc, #84]	; (30c <Init125khz+0x58>)
 2b8:	2240      	movs	r2, #64	; 0x40
 2ba:	5c98      	ldrb	r0, [r3, r2]
 2bc:	2101      	movs	r1, #1
 2be:	4301      	orrs	r1, r0
 2c0:	5499      	strb	r1, [r3, r2]
	PORT->Group[0].PMUX[0].bit.PMUXE= 0x5; //Periférico F = TC2/WO[0]
 2c2:	2230      	movs	r2, #48	; 0x30
 2c4:	5c99      	ldrb	r1, [r3, r2]
 2c6:	200f      	movs	r0, #15
 2c8:	4381      	bics	r1, r0
 2ca:	2005      	movs	r0, #5
 2cc:	4301      	orrs	r1, r0
 2ce:	5499      	strb	r1, [r3, r2]
	
	//Habilita o clock do TC2
	PM->APBCMASK.reg |= PM_APBCMASK_TC2;
 2d0:	4b0f      	ldr	r3, [pc, #60]	; (310 <Init125khz+0x5c>)
 2d2:	6a19      	ldr	r1, [r3, #32]
 2d4:	2280      	movs	r2, #128	; 0x80
 2d6:	00d2      	lsls	r2, r2, #3
 2d8:	430a      	orrs	r2, r1
 2da:	621a      	str	r2, [r3, #32]
		
	//Reseta o TC2
	TC2->COUNT16.CTRLA.bit.SWRST = 1;
 2dc:	4b0d      	ldr	r3, [pc, #52]	; (314 <Init125khz+0x60>)
 2de:	8819      	ldrh	r1, [r3, #0]
 2e0:	2201      	movs	r2, #1
 2e2:	430a      	orrs	r2, r1
 2e4:	801a      	strh	r2, [r3, #0]
	while (TC2->COUNT16.CTRLA.bit.SWRST!=0);
 2e6:	1c19      	adds	r1, r3, #0
 2e8:	2201      	movs	r2, #1
 2ea:	880b      	ldrh	r3, [r1, #0]
 2ec:	421a      	tst	r2, r3
 2ee:	d1fc      	bne.n	2ea <Init125khz+0x36>
	
	//Configura o TC2
	TC2->COUNT16.CTRLA.reg = TC_CTRLA_WAVEGEN_MFRQ; //GCLK/1, não roda em STBY, MFRQ, COUNT16, Disable
 2f0:	4b08      	ldr	r3, [pc, #32]	; (314 <Init125khz+0x60>)
 2f2:	2220      	movs	r2, #32
 2f4:	801a      	strh	r2, [r3, #0]
	TC2->COUNT16.CTRLBSET.reg = 0; //Count up infinitamente
 2f6:	2200      	movs	r2, #0
 2f8:	715a      	strb	r2, [r3, #5]
	TC2->COUNT16.CTRLC.reg = 0; //Sem capture/Compare e não inverte nenhuma saída 
 2fa:	719a      	strb	r2, [r3, #6]
	TC2->COUNT16.CC[0].reg = 31; //Valor para 8MHz é 32 (para 48MHz é 384/2)
 2fc:	221f      	movs	r2, #31
 2fe:	831a      	strh	r2, [r3, #24]
		
	//Habilita o TC2
	TC2->COUNT16.CTRLA.bit.ENABLE = 1;
 300:	8819      	ldrh	r1, [r3, #0]
 302:	2202      	movs	r2, #2
 304:	430a      	orrs	r2, r1
 306:	801a      	strh	r2, [r3, #0]
}
 308:	bd00      	pop	{pc}
 30a:	46c0      	nop			; (mov r8, r8)
 30c:	41004400 	.word	0x41004400
 310:	40000400 	.word	0x40000400
 314:	42002800 	.word	0x42002800

00000318 <main>:

volatile uint32_t a;

int main(void)
{
 318:	b508      	push	{r3, lr}
    /* Initialize the SAM system */
	//Esse system Init parece inútil e errado
    //SystemInit();
	/* Inicializa os clocks */
	ClockInit();
 31a:	4b07      	ldr	r3, [pc, #28]	; (338 <main+0x20>)
 31c:	4798      	blx	r3
	Init125khz();
 31e:	4b07      	ldr	r3, [pc, #28]	; (33c <main+0x24>)
 320:	4798      	blx	r3

	TC2->COUNT16.COUNT.reg = 22;
 322:	4b07      	ldr	r3, [pc, #28]	; (340 <main+0x28>)
 324:	2216      	movs	r2, #22
 326:	821a      	strh	r2, [r3, #16]
	a=TC2->COUNT16.COUNT.reg;
 328:	8a1a      	ldrh	r2, [r3, #16]
 32a:	4b06      	ldr	r3, [pc, #24]	; (344 <main+0x2c>)
 32c:	601a      	str	r2, [r3, #0]

    while (1) 
    {
        //TODO:: Please write your application code 
		a=TC2->COUNT16.COUNT.reg;
 32e:	4904      	ldr	r1, [pc, #16]	; (340 <main+0x28>)
 330:	1c1a      	adds	r2, r3, #0
 332:	8a0b      	ldrh	r3, [r1, #16]
 334:	6013      	str	r3, [r2, #0]
 336:	e7fc      	b.n	332 <main+0x1a>
 338:	000001f5 	.word	0x000001f5
 33c:	000002b5 	.word	0x000002b5
 340:	42002800 	.word	0x42002800
 344:	2000044c 	.word	0x2000044c

00000348 <__register_exitproc>:
 348:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 34a:	1c1e      	adds	r6, r3, #0
 34c:	4b23      	ldr	r3, [pc, #140]	; (3dc <__register_exitproc+0x94>)
 34e:	1c17      	adds	r7, r2, #0
 350:	681a      	ldr	r2, [r3, #0]
 352:	1c05      	adds	r5, r0, #0
 354:	1c14      	adds	r4, r2, #0
 356:	34fc      	adds	r4, #252	; 0xfc
 358:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 35a:	9101      	str	r1, [sp, #4]
 35c:	2800      	cmp	r0, #0
 35e:	d103      	bne.n	368 <__register_exitproc+0x20>
 360:	21a6      	movs	r1, #166	; 0xa6
 362:	0048      	lsls	r0, r1, #1
 364:	1810      	adds	r0, r2, r0
 366:	64e0      	str	r0, [r4, #76]	; 0x4c
 368:	6843      	ldr	r3, [r0, #4]
 36a:	2b1f      	cmp	r3, #31
 36c:	dd16      	ble.n	39c <__register_exitproc+0x54>
 36e:	4a1c      	ldr	r2, [pc, #112]	; (3e0 <__register_exitproc+0x98>)
 370:	2a00      	cmp	r2, #0
 372:	d102      	bne.n	37a <__register_exitproc+0x32>
 374:	2001      	movs	r0, #1
 376:	4240      	negs	r0, r0
 378:	e02f      	b.n	3da <__register_exitproc+0x92>
 37a:	21c8      	movs	r1, #200	; 0xc8
 37c:	0048      	lsls	r0, r1, #1
 37e:	e000      	b.n	382 <__register_exitproc+0x3a>
 380:	bf00      	nop
 382:	2800      	cmp	r0, #0
 384:	d0f6      	beq.n	374 <__register_exitproc+0x2c>
 386:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 388:	2300      	movs	r3, #0
 38a:	6002      	str	r2, [r0, #0]
 38c:	6043      	str	r3, [r0, #4]
 38e:	22c6      	movs	r2, #198	; 0xc6
 390:	64e0      	str	r0, [r4, #76]	; 0x4c
 392:	24c4      	movs	r4, #196	; 0xc4
 394:	0061      	lsls	r1, r4, #1
 396:	0054      	lsls	r4, r2, #1
 398:	5043      	str	r3, [r0, r1]
 39a:	5103      	str	r3, [r0, r4]
 39c:	6843      	ldr	r3, [r0, #4]
 39e:	2d00      	cmp	r5, #0
 3a0:	d014      	beq.n	3cc <__register_exitproc+0x84>
 3a2:	1c04      	adds	r4, r0, #0
 3a4:	3488      	adds	r4, #136	; 0x88
 3a6:	0099      	lsls	r1, r3, #2
 3a8:	510f      	str	r7, [r1, r4]
 3aa:	27c2      	movs	r7, #194	; 0xc2
 3ac:	007a      	lsls	r2, r7, #1
 3ae:	1882      	adds	r2, r0, r2
 3b0:	6857      	ldr	r7, [r2, #4]
 3b2:	2101      	movs	r1, #1
 3b4:	4099      	lsls	r1, r3
 3b6:	430f      	orrs	r7, r1
 3b8:	6057      	str	r7, [r2, #4]
 3ba:	1c1f      	adds	r7, r3, #0
 3bc:	3720      	adds	r7, #32
 3be:	00bf      	lsls	r7, r7, #2
 3c0:	513e      	str	r6, [r7, r4]
 3c2:	2d02      	cmp	r5, #2
 3c4:	d102      	bne.n	3cc <__register_exitproc+0x84>
 3c6:	6895      	ldr	r5, [r2, #8]
 3c8:	4329      	orrs	r1, r5
 3ca:	6091      	str	r1, [r2, #8]
 3cc:	1c9e      	adds	r6, r3, #2
 3ce:	9901      	ldr	r1, [sp, #4]
 3d0:	00b4      	lsls	r4, r6, #2
 3d2:	3301      	adds	r3, #1
 3d4:	5021      	str	r1, [r4, r0]
 3d6:	6043      	str	r3, [r0, #4]
 3d8:	2000      	movs	r0, #0
 3da:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 3dc:	00000484 	.word	0x00000484
 3e0:	00000000 	.word	0x00000000

000003e4 <__libc_fini_array>:
 3e4:	b538      	push	{r3, r4, r5, lr}
 3e6:	4b08      	ldr	r3, [pc, #32]	; (408 <__libc_fini_array+0x24>)
 3e8:	4c08      	ldr	r4, [pc, #32]	; (40c <__libc_fini_array+0x28>)
 3ea:	1c1d      	adds	r5, r3, #0
 3ec:	1ae0      	subs	r0, r4, r3
 3ee:	1084      	asrs	r4, r0, #2
 3f0:	2c00      	cmp	r4, #0
 3f2:	d006      	beq.n	402 <__libc_fini_array+0x1e>
 3f4:	00a1      	lsls	r1, r4, #2
 3f6:	186a      	adds	r2, r5, r1
 3f8:	3a04      	subs	r2, #4
 3fa:	6813      	ldr	r3, [r2, #0]
 3fc:	4798      	blx	r3
 3fe:	3c01      	subs	r4, #1
 400:	e7f6      	b.n	3f0 <__libc_fini_array+0xc>
 402:	f000 f84d 	bl	4a0 <_fini>
 406:	bd38      	pop	{r3, r4, r5, pc}
 408:	000004ac 	.word	0x000004ac
 40c:	000004b0 	.word	0x000004b0

00000410 <__libc_init_array>:
 410:	b570      	push	{r4, r5, r6, lr}
 412:	4b0e      	ldr	r3, [pc, #56]	; (44c <__libc_init_array+0x3c>)
 414:	4d0e      	ldr	r5, [pc, #56]	; (450 <__libc_init_array+0x40>)
 416:	2400      	movs	r4, #0
 418:	1ae8      	subs	r0, r5, r3
 41a:	1085      	asrs	r5, r0, #2
 41c:	1c1e      	adds	r6, r3, #0
 41e:	42ac      	cmp	r4, r5
 420:	d004      	beq.n	42c <__libc_init_array+0x1c>
 422:	00a1      	lsls	r1, r4, #2
 424:	5872      	ldr	r2, [r6, r1]
 426:	4790      	blx	r2
 428:	3401      	adds	r4, #1
 42a:	e7f8      	b.n	41e <__libc_init_array+0xe>
 42c:	f000 f82e 	bl	48c <_init>
 430:	4908      	ldr	r1, [pc, #32]	; (454 <__libc_init_array+0x44>)
 432:	4a09      	ldr	r2, [pc, #36]	; (458 <__libc_init_array+0x48>)
 434:	1c0e      	adds	r6, r1, #0
 436:	1a54      	subs	r4, r2, r1
 438:	10a5      	asrs	r5, r4, #2
 43a:	2400      	movs	r4, #0
 43c:	42ac      	cmp	r4, r5
 43e:	d004      	beq.n	44a <__libc_init_array+0x3a>
 440:	00a3      	lsls	r3, r4, #2
 442:	58f0      	ldr	r0, [r6, r3]
 444:	4780      	blx	r0
 446:	3401      	adds	r4, #1
 448:	e7f8      	b.n	43c <__libc_init_array+0x2c>
 44a:	bd70      	pop	{r4, r5, r6, pc}
 44c:	00000498 	.word	0x00000498
 450:	00000498 	.word	0x00000498
 454:	00000498 	.word	0x00000498
 458:	000004a0 	.word	0x000004a0

0000045c <register_fini>:
 45c:	b508      	push	{r3, lr}
 45e:	4b03      	ldr	r3, [pc, #12]	; (46c <register_fini+0x10>)
 460:	2b00      	cmp	r3, #0
 462:	d002      	beq.n	46a <register_fini+0xe>
 464:	4802      	ldr	r0, [pc, #8]	; (470 <register_fini+0x14>)
 466:	f000 f805 	bl	474 <atexit>
 46a:	bd08      	pop	{r3, pc}
 46c:	00000000 	.word	0x00000000
 470:	000003e5 	.word	0x000003e5

00000474 <atexit>:
 474:	b508      	push	{r3, lr}
 476:	1c01      	adds	r1, r0, #0
 478:	2000      	movs	r0, #0
 47a:	1c02      	adds	r2, r0, #0
 47c:	1c03      	adds	r3, r0, #0
 47e:	f7ff ff63 	bl	348 <__register_exitproc>
 482:	bd08      	pop	{r3, pc}

00000484 <_global_impure_ptr>:
 484:	0008 2000 0043 0000                         ... C...

0000048c <_init>:
 48c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 48e:	46c0      	nop			; (mov r8, r8)
 490:	bcf8      	pop	{r3, r4, r5, r6, r7}
 492:	bc08      	pop	{r3}
 494:	469e      	mov	lr, r3
 496:	4770      	bx	lr

00000498 <__init_array_start>:
 498:	0000045d 	.word	0x0000045d

0000049c <__frame_dummy_init_array_entry>:
 49c:	00000121                                !...

000004a0 <_fini>:
 4a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 4a2:	46c0      	nop			; (mov r8, r8)
 4a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 4a6:	bc08      	pop	{r3}
 4a8:	469e      	mov	lr, r3
 4aa:	4770      	bx	lr

000004ac <__fini_array_start>:
 4ac:	000000f5 	.word	0x000000f5
